/**
 * complete_task MCP Tool
 *
 * Complete a task and compute file changes via Git diff.
 * This is the MOST CRITICAL tool - it calculates the union of committed + working tree changes.
 */

import { z } from 'zod'
import { prisma } from '../db.js'
import {
  computeGitDiff,
  verifyScope,
  type GitSnapshotData,
} from '../utils/git-snapshot.js'
import {
  toJsonArray,
  fromJsonArray,
  fromJsonObject,
} from '../utils/json-fields.js'
import {
  emitTaskUpdated,
  emitWorkflowUpdated,
  emitPhaseUpdated,
  emitMissionUpdated,
} from '../websocket/index.js'
import { NotFoundError, ValidationError } from '../utils/errors.js'
import {
  taskStatusMap,
  testsStatusMap,
  TaskStatus,
  WorkflowStatus,
  PhaseStatus,
} from '../types/enums.js'
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js'

// Zod schema for validation
const completeTaskSchema = z.object({
  task_id: z.string().min(1),
  status: z.enum(['success', 'partial_success', 'failed']),
  outcome: z.object({
    summary: z.string().min(1),
    achievements: z.array(z.string()).optional(),
    limitations: z.array(z.string()).optional(),
    manual_review_needed: z.boolean().optional(),
    manual_review_reason: z.string().optional(),
    next_steps: z.array(z.string()).optional(),
  }),
  metadata: z
    .object({
      packages_added: z.array(z.string()).optional(),
      packages_removed: z.array(z.string()).optional(),
      commands_executed: z.array(z.string()).optional(),
      tests_status: z.enum(['passed', 'failed', 'not_run']).optional(),
      tokens_input: z.number().int().nonnegative().optional(),
      tokens_output: z.number().int().nonnegative().optional(),
    })
    .optional(),
  // Mission system: phase completion
  phase_complete: z.boolean().optional().default(false),
})

// MCP Tool definition
export const completeTaskTool = {
  name: 'complete_task',
  description: 'Complete a task and compute file changes via Git diff',
  inputSchema: {
    type: 'object' as const,
    properties: {
      task_id: {
        type: 'string',
        description: 'Task ID to complete',
      },
      status: {
        type: 'string',
        enum: ['success', 'partial_success', 'failed'],
        description: 'Final status of the task',
      },
      outcome: {
        type: 'object',
        properties: {
          summary: {
            type: 'string',
            description: 'Summary of what was accomplished (2-4 sentences)',
          },
          achievements: {
            type: 'array',
            items: { type: 'string' },
            description: 'Concrete achievements (empty array if none)',
          },
          limitations: {
            type: 'array',
            items: { type: 'string' },
            description: 'Limitations/compromises (empty array if none)',
          },
          manual_review_needed: {
            type: 'boolean',
            description: 'Does a human need to review before continuing?',
          },
          manual_review_reason: {
            type: 'string',
            description: 'Why manual review is needed',
          },
          next_steps: {
            type: 'array',
            items: { type: 'string' },
            description: 'Suggested next steps (optional)',
          },
        },
        required: ['summary'],
      },
      metadata: {
        type: 'object',
        properties: {
          packages_added: {
            type: 'array',
            items: { type: 'string' },
          },
          packages_removed: {
            type: 'array',
            items: { type: 'string' },
          },
          commands_executed: {
            type: 'array',
            items: { type: 'string' },
          },
          tests_status: {
            type: 'string',
            enum: ['passed', 'failed', 'not_run'],
          },
          tokens_input: {
            type: 'number',
            description: 'Number of input tokens used by this task',
          },
          tokens_output: {
            type: 'number',
            description: 'Number of output tokens generated by this task',
          },
        },
      },
      phase_complete: {
        type: 'boolean',
        description: 'Set to true to mark the current phase as complete',
      },
    },
    required: ['task_id', 'status', 'outcome'],
  },
}

// Handler
export async function handleCompleteTask(
  args: unknown
): Promise<CallToolResult> {
  // Validate input
  const validated = completeTaskSchema.parse(args)

  // Fetch task with snapshot data
  const task = await prisma.task.findUnique({
    where: { id: validated.task_id },
  })

  if (!task) {
    throw new NotFoundError(`Task not found: ${validated.task_id}`)
  }

  if (task.status !== TaskStatus.IN_PROGRESS) {
    throw new ValidationError(
      `Task is not in progress: ${task.status}`
    )
  }

  // Check if this task has any subtasks still in progress
  const incompleteSubtasks = await prisma.task.findMany({
    where: {
      parentTaskId: validated.task_id,
      status: TaskStatus.IN_PROGRESS,
    },
    select: { id: true, name: true },
  })

  if (incompleteSubtasks.length > 0) {
    const subtaskNames = incompleteSubtasks.map((t) => t.name).join(', ')
    throw new ValidationError(
      `Cannot complete task: ${incompleteSubtasks.length} subtask(s) still in progress (${subtaskNames})`
    )
  }

  // Calculate completion time
  const completedAt = new Date()
  const durationMs = completedAt.getTime() - task.startedAt.getTime()

  // Compute Git diff (CRITICAL: Union of committed + working tree changes)
  let filesAdded: string[] = []
  let filesModified: string[] = []
  let filesDeleted: string[] = []

  if (task.snapshotType === 'git' && task.snapshotData) {
    // SQLite: snapshotData is stored as JSON string
    const snapshotData = fromJsonObject<GitSnapshotData>(task.snapshotData)
    if (snapshotData?.gitHash) {
      const diff = await computeGitDiff(snapshotData.gitHash)
      filesAdded = diff.added
      filesModified = diff.modified
      filesDeleted = diff.deleted
    }
  }

  // Verify scope
  const allChangedFiles = [...filesAdded, ...filesModified, ...filesDeleted]
  // SQLite: areas is stored as JSON string
  const taskAreas = fromJsonArray<string>(task.areas)
  const scopeVerification = verifyScope(allChangedFiles, taskAreas)

  // Map status to Prisma enum
  const taskStatus = taskStatusMap[validated.status]
  if (!taskStatus) {
    throw new ValidationError(`Invalid task status: ${validated.status}`)
  }

  // Map tests status if provided
  let testsStatus = null
  if (validated.metadata?.tests_status) {
    testsStatus = testsStatusMap[validated.metadata.tests_status] ?? null
  }

  // Update task in database
  const updatedTask = await prisma.task.update({
    where: { id: validated.task_id },
    data: {
      status: taskStatus,
      completedAt,
      durationMs,
      summary: validated.outcome.summary,
      achievements: toJsonArray(validated.outcome.achievements),
      limitations: toJsonArray(validated.outcome.limitations),
      manualReviewNeeded: validated.outcome.manual_review_needed ?? false,
      manualReviewReason: validated.outcome.manual_review_reason,
      nextSteps: toJsonArray(validated.outcome.next_steps),
      packagesAdded: toJsonArray(validated.metadata?.packages_added),
      packagesRemoved: toJsonArray(validated.metadata?.packages_removed),
      commandsExecuted: toJsonArray(validated.metadata?.commands_executed),
      testsStatus,
      tokensInput: validated.metadata?.tokens_input,
      tokensOutput: validated.metadata?.tokens_output,
      filesAdded: toJsonArray(filesAdded),
      filesModified: toJsonArray(filesModified),
      filesDeleted: toJsonArray(filesDeleted),
      scopeMatch: scopeVerification.scopeMatch,
      unexpectedFiles: toJsonArray(scopeVerification.unexpectedFiles),
      warnings: toJsonArray(scopeVerification.warnings),
    },
  })

  // Emit WebSocket event for real-time UI update
  emitTaskUpdated(updatedTask, task.workflowId)

  // Build response
  const response: Record<string, unknown> = {
    task_id: updatedTask.id,
    duration_seconds: Math.round(durationMs / 1000),
    files_changed: {
      added: filesAdded,
      modified: filesModified,
      deleted: filesDeleted,
    },
    verification: {
      scope_match: scopeVerification.scopeMatch,
      unexpected_files: scopeVerification.unexpectedFiles,
      warnings: scopeVerification.warnings,
    },
  }

  // Handle phase completion if task belongs to a phase
  if (task.phaseId && validated.phase_complete) {
    const phase = await prisma.phase.findUnique({
      where: { id: task.phaseId },
      include: { mission: true },
    })

    if (phase) {
      // Update phase status to COMPLETED
      const updatedPhase = await prisma.phase.update({
        where: { id: phase.id },
        data: {
          status: PhaseStatus.COMPLETED,
          completedAt: new Date(),
        },
      })

      emitPhaseUpdated(updatedPhase, phase.missionId)

      // Update mission currentPhase
      const updatedMission = await prisma.mission.update({
        where: { id: phase.missionId },
        data: {
          currentPhase: phase.number,
        },
      })

      emitMissionUpdated(updatedMission)

      response.phase_status = 'completed'
      response.phase_number = phase.number
    }
  } else if (task.phaseId) {
    // Just report current phase status
    const phase = await prisma.phase.findUnique({
      where: { id: task.phaseId },
    })
    if (phase) {
      response.phase_status = phase.status.toLowerCase()
      response.phase_number = phase.number
    }
  }

  // Check if workflow should be completed (legacy mode)
  // (All tasks in workflow are complete)
  if (task.workflowId && task.workflowId !== 'mission-task') {
    const updatedWorkflow = await checkAndUpdateWorkflowStatus(task.workflowId)
    if (updatedWorkflow) {
      emitWorkflowUpdated(updatedWorkflow)
    }
  }

  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(response, null, 2),
      },
    ],
  }
}

/**
 * Check if all tasks in a workflow are complete and update workflow status.
 * Also computes aggregated metrics (totalDurationMs, totalTokens).
 *
 * Status logic:
 * - If ANY task is IN_PROGRESS → workflow stays IN_PROGRESS
 * - If ANY task is FAILED → workflow is FAILED
 * - If ANY task is PARTIAL_SUCCESS (and none FAILED) → workflow is PARTIAL_SUCCESS
 * - If ALL tasks are SUCCESS → workflow is COMPLETED
 *
 * Returns the updated workflow if status changed, null otherwise.
 */
async function checkAndUpdateWorkflowStatus(
  workflowId: string
): Promise<Awaited<ReturnType<typeof prisma.workflow.update>> | null> {
  const tasks = await prisma.task.findMany({
    where: { workflowId },
    select: {
      status: true,
      durationMs: true,
      tokensInput: true,
      tokensOutput: true,
    },
  })

  if (tasks.length === 0) {
    return null
  }

  // Check if any task is still in progress
  const anyInProgress = tasks.some(
    (task) => task.status === TaskStatus.IN_PROGRESS
  )

  if (anyInProgress) {
    // Workflow stays IN_PROGRESS, but still update metrics
    const metrics = computeWorkflowMetrics(tasks)
    await prisma.workflow.update({
      where: { id: workflowId },
      data: metrics,
    })
    return null
  }

  // All tasks are complete, determine final workflow status
  const anyFailed = tasks.some((task) => task.status === TaskStatus.FAILED)
  const anyPartialSuccess = tasks.some(
    (task) => task.status === TaskStatus.PARTIAL_SUCCESS
  )

  let newStatus: WorkflowStatus
  if (anyFailed || anyPartialSuccess) {
    // If any task failed or had partial success, mark workflow as FAILED
    newStatus = WorkflowStatus.FAILED
  } else {
    // All tasks succeeded
    newStatus = WorkflowStatus.COMPLETED
  }

  // Compute aggregated metrics
  const metrics = computeWorkflowMetrics(tasks)

  const updatedWorkflow = await prisma.workflow.update({
    where: { id: workflowId },
    data: {
      status: newStatus,
      ...metrics,
    },
  })

  return updatedWorkflow
}

/**
 * Compute aggregated metrics from tasks.
 */
function computeWorkflowMetrics(
  tasks: { durationMs: number | null; tokensInput: number | null; tokensOutput: number | null }[]
): { totalDurationMs: number; totalTokens: number } {
  let totalDurationMs = 0
  let totalTokens = 0

  for (const task of tasks) {
    if (task.durationMs) {
      totalDurationMs += task.durationMs
    }
    if (task.tokensInput) {
      totalTokens += task.tokensInput
    }
    if (task.tokensOutput) {
      totalTokens += task.tokensOutput
    }
  }

  return { totalDurationMs, totalTokens }
}
